### MSA

> 단일 프로그램을 각 컴포넌트 별로 나누어 작은 서비스의 조합으로 구축하는 방법

- 서비스를 분화시키고, 서비스에 대한 관리를 위임시키는 것

- MSA 어플리케이션마다 언어나 프레임워크가 다름 -> MSA의 장점!

- 자동화가 제일 중요!

- 기존: Monolithic Architecture

  - 소프트웨어의 모든 구성요소가 한 프로젝트에 통합되어 있는 형태

  - 모듈별로 개발=> 개발 완료 시 웹 어플리케이션을 결과물로 패키징 후 배포
  - 고객이 요구하는 것을 즉각적으로 반영 -> 코드에 반영하는 것은 쉬움

  - 반영하고 나서 서버 하나하나에 반영하려면 배포하는 것이 너무 어려워진다

    => **자동화가 되는 것이 제일 중요**

  - 부분 장애 -> 서비스 장애로 확대 가능

  - scale out 처리 어려움

  - 프레임워크와 언어에 따라 개발 달라짐



![img](C:\Users\MIN\Downloads\img.jpg)







## 암호화

> 평문(Plain Text)==>암호문으로 바꾸는 과정



- 평문에서 알고리즘을 통해 암호문으로 만드는 과정: 암호화

- 암호문에서 알고리즘과 키를 통해 평문으로 만드는 과정: 복호화



### 암호시스템

키 구성에 따라 대칭 키 암호화 방식과 비대칭 암호화 방식으로 구분 가능

대칭키: 암호화 과정에 사용된 키와 복호화 과정에 사용된 키가 동일

= 유일키

= 다른 사람이 가지고 있으면 안되기 때문에 비밀키, 시크릿 키라고도 함

= 관용 암호화 방식

- 단점

  - 키 관리 및 분배 어려움

    - 송신자가 수신자에게 데이터를 보냄 -> 그냥 보내면 제 3자가 중간에 열람 가능

      => 싸이퍼 함수로 암호화된 데이터를 보냄

      - 키를 가지고 암호화해 전달하면 중간에 제 3자가 볼 수 없음
      - 수신자도 복호화에 필요한 키를 가지고 있지 않음

    - 수신자(통신 대상자)가 많아지면 관리해야 할 키가 증가 => 키 관리 문제



### 비대칭키

- 암호화 과정에 사용된 키와 복호화 과정에 사용된 키가 상이

  - 송신자: 프라이빗 키-공개 키로 구성된 키 쌍 생성

  - 유일키의 개념이 깨짐

    - 개인 키는 외부에 오픈되지 않음

    - 공개 키는 외부에 오픈해도 무관

      => 비밀 키의 개념이 깨짐

      => 공개키 암호화 방식

  > 개인 키로 암호화한 것은 공개 키로 복호화 할 수 있고
  >
  > 공개 키로 암호화한 것은 개인 키로 복호화 할 수 있음

  ![image-20210310140659453](C:\Users\MIN\AppData\Roaming\Typora\typora-user-images\image-20210310140659453.png)

  

![image-20210310141020533](C:\Users\MIN\AppData\Roaming\Typora\typora-user-images\image-20210310141020533.png)

- 송신자가 수신자 A만 볼 수 있도록 데이터를 전달하는 방법 => 기밀성 서비스 구현
  - 수신자A의 공개키를 취득
  - 수신자A의 공개 키로 데이터를 암호화ㄴ
  - 암호화된 데이터를 전달
  - 수신자 A는 자신의 개인 키로 암호화된 데이터를 복호화

- 원본증명, 부인방지, 인증 등의 서비스를 구현

  (1) 송신자가 본의 개인키로 암호화해서 전달 ⇒ "서명한다"

  (2) 암호화된 데이터와 암호화된 데이터를 복호화하는데 필요한 공개키는 누구나 취득이 가능

  (3) 암호화된 데이터가 송신자의 공개키로 복호화된다는 것   

  ⇒ 송신자의 개인키로 암화된 것

   = 암호화된 데이터가 송신자가 만들 것이 확실 

   ⇒ "서명검증한다"

  

- 키 페어 생성 시  개인 키와 공개 키로 만든다-> 개인 키는 저장/공개 키는 인스턴스 내에 저장
- 키가 외부에 노출 시 AWS측에서 계정 잠금

